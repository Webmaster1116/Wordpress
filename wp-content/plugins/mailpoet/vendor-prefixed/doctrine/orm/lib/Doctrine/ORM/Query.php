<?php
 namespace MailPoetVendor\Doctrine\ORM; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\Common\Collections\ArrayCollection; use MailPoetVendor\Doctrine\DBAL\LockMode; use MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata; use MailPoetVendor\Doctrine\ORM\Query\AST\DeleteStatement; use MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement; use MailPoetVendor\Doctrine\ORM\Query\AST\UpdateStatement; use MailPoetVendor\Doctrine\ORM\Query\Exec\AbstractSqlExecutor; use MailPoetVendor\Doctrine\ORM\Query\Parameter; use MailPoetVendor\Doctrine\ORM\Query\ParameterTypeInferer; use MailPoetVendor\Doctrine\ORM\Query\Parser; use MailPoetVendor\Doctrine\ORM\Query\ParserResult; use MailPoetVendor\Doctrine\ORM\Query\QueryException; use MailPoetVendor\Doctrine\ORM\Utility\HierarchyDiscriminatorResolver; use function array_keys; use function assert; final class Query extends \MailPoetVendor\Doctrine\ORM\AbstractQuery { const STATE_CLEAN = 1; const STATE_DIRTY = 2; const HINT_REFRESH = 'doctrine.refresh'; const HINT_CACHE_ENABLED = 'doctrine.cache.enabled'; const HINT_CACHE_EVICT = 'doctrine.cache.evict'; const HINT_REFRESH_ENTITY = 'doctrine.refresh.entity'; const HINT_FORCE_PARTIAL_LOAD = 'doctrine.forcePartialLoad'; const HINT_INCLUDE_META_COLUMNS = 'doctrine.includeMetaColumns'; const HINT_CUSTOM_TREE_WALKERS = 'doctrine.customTreeWalkers'; const HINT_CUSTOM_OUTPUT_WALKER = 'doctrine.customOutputWalker'; const HINT_INTERNAL_ITERATION = 'doctrine.internal.iteration'; const HINT_LOCK_MODE = 'doctrine.lockMode'; private $_state = self::STATE_DIRTY; private $_parsedTypes = []; private $_dql = null; private $_parserResult; private $_firstResult = null; private $_maxResults = null; private $_queryCache; private $_expireQueryCache = \false; private $_queryCacheTTL; private $_useQueryCache = \true; public function getSQL() { return $this->_parse()->getSqlExecutor()->getSqlStatements(); } public function getAST() { $parser = new \MailPoetVendor\Doctrine\ORM\Query\Parser($this); return $parser->getAST(); } protected function getResultSetMapping() { if ($this->_resultSetMapping === null) { $this->_resultSetMapping = $this->_parse()->getResultSetMapping(); } return $this->_resultSetMapping; } private function _parse() { $types = []; foreach ($this->parameters as $parameter) { $types[$parameter->getName()] = $parameter->getType(); } if ($this->_state === self::STATE_CLEAN && $this->_parsedTypes === $types && $this->_em->isFiltersStateClean()) { return $this->_parserResult; } $this->_state = self::STATE_CLEAN; $this->_parsedTypes = $types; if (!($this->_useQueryCache && ($queryCache = $this->getQueryCacheDriver()))) { $parser = new \MailPoetVendor\Doctrine\ORM\Query\Parser($this); $this->_parserResult = $parser->parse(); return $this->_parserResult; } $hash = $this->_getQueryCacheId(); $cached = $this->_expireQueryCache ? \false : $queryCache->fetch($hash); if ($cached instanceof \MailPoetVendor\Doctrine\ORM\Query\ParserResult) { $this->_parserResult = $cached; return $this->_parserResult; } $parser = new \MailPoetVendor\Doctrine\ORM\Query\Parser($this); $this->_parserResult = $parser->parse(); $queryCache->save($hash, $this->_parserResult, $this->_queryCacheTTL); return $this->_parserResult; } protected function _doExecute() { $executor = $this->_parse()->getSqlExecutor(); if ($this->_queryCacheProfile) { $executor->setQueryCacheProfile($this->_queryCacheProfile); } else { $executor->removeQueryCacheProfile(); } if ($this->_resultSetMapping === null) { $this->_resultSetMapping = $this->_parserResult->getResultSetMapping(); } $paramMappings = $this->_parserResult->getParameterMappings(); $paramCount = \count($this->parameters); $mappingCount = \count($paramMappings); if ($paramCount > $mappingCount) { throw \MailPoetVendor\Doctrine\ORM\Query\QueryException::tooManyParameters($mappingCount, $paramCount); } if ($paramCount < $mappingCount) { throw \MailPoetVendor\Doctrine\ORM\Query\QueryException::tooFewParameters($mappingCount, $paramCount); } if ($this->hasCache && isset($this->_hints[self::HINT_CACHE_EVICT]) && $this->_hints[self::HINT_CACHE_EVICT]) { $this->evictEntityCacheRegion(); } [$sqlParams, $types] = $this->processParameterMappings($paramMappings); $this->evictResultSetCache($executor, $sqlParams, $types, $this->_em->getConnection()->getParams()); return $executor->execute($this->_em->getConnection(), $sqlParams, $types); } private function evictResultSetCache(\MailPoetVendor\Doctrine\ORM\Query\Exec\AbstractSqlExecutor $executor, array $sqlParams, array $types, array $connectionParams) { if (null === $this->_queryCacheProfile || !$this->getExpireResultCache()) { return; } $cacheDriver = $this->_queryCacheProfile->getResultCacheDriver(); $statements = (array) $executor->getSqlStatements(); foreach ($statements as $statement) { $cacheKeys = $this->_queryCacheProfile->generateCacheKeys($statement, $sqlParams, $types, $connectionParams); $cacheDriver->delete(\reset($cacheKeys)); } } private function evictEntityCacheRegion() { $AST = $this->getAST(); if ($AST instanceof \MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement) { throw new \MailPoetVendor\Doctrine\ORM\Query\QueryException('The hint "HINT_CACHE_EVICT" is not valid for select statements.'); } $className = $AST instanceof \MailPoetVendor\Doctrine\ORM\Query\AST\DeleteStatement ? $AST->deleteClause->abstractSchemaName : $AST->updateClause->abstractSchemaName; $this->_em->getCache()->evictEntityRegion($className); } private function processParameterMappings($paramMappings) : array { $sqlParams = []; $types = []; foreach ($this->parameters as $parameter) { $key = $parameter->getName(); if (!isset($paramMappings[$key])) { throw \MailPoetVendor\Doctrine\ORM\Query\QueryException::unknownParameter($key); } [$value, $type] = $this->resolveParameterValue($parameter); foreach ($paramMappings[$key] as $position) { $types[$position] = $type; } $sqlPositions = $paramMappings[$key]; $value = [$value]; $countValue = \count($value); for ($i = 0, $l = \count($sqlPositions); $i < $l; $i++) { $sqlParams[$sqlPositions[$i]] = $value[$i % $countValue]; } } if (\count($sqlParams) != \count($types)) { throw \MailPoetVendor\Doctrine\ORM\Query\QueryException::parameterTypeMismatch(); } if ($sqlParams) { \ksort($sqlParams); $sqlParams = \array_values($sqlParams); \ksort($types); $types = \array_values($types); } return [$sqlParams, $types]; } private function resolveParameterValue(\MailPoetVendor\Doctrine\ORM\Query\Parameter $parameter) : array { if ($parameter->typeWasSpecified()) { return [$parameter->getValue(), $parameter->getType()]; } $key = $parameter->getName(); $originalValue = $parameter->getValue(); $value = $originalValue; $rsm = $this->getResultSetMapping(); \assert($rsm !== null); if ($value instanceof \MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata && isset($rsm->metadataParameterMapping[$key])) { $value = $value->getMetadataValue($rsm->metadataParameterMapping[$key]); } if ($value instanceof \MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata && isset($rsm->discriminatorParameters[$key])) { $value = \array_keys(\MailPoetVendor\Doctrine\ORM\Utility\HierarchyDiscriminatorResolver::resolveDiscriminatorsForClass($value, $this->_em)); } $processedValue = $this->processParameterValue($value); return [$processedValue, $originalValue === $processedValue ? $parameter->getType() : \MailPoetVendor\Doctrine\ORM\Query\ParameterTypeInferer::inferType($processedValue)]; } public function setQueryCacheDriver($queryCache) : self { $this->_queryCache = $queryCache; return $this; } public function useQueryCache($bool) : self { $this->_useQueryCache = $bool; return $this; } public function getQueryCacheDriver() { if ($this->_queryCache) { return $this->_queryCache; } return $this->_em->getConfiguration()->getQueryCacheImpl(); } public function setQueryCacheLifetime($timeToLive) : self { if ($timeToLive !== null) { $timeToLive = (int) $timeToLive; } $this->_queryCacheTTL = $timeToLive; return $this; } public function getQueryCacheLifetime() { return $this->_queryCacheTTL; } public function expireQueryCache($expire = \true) : self { $this->_expireQueryCache = $expire; return $this; } public function getExpireQueryCache() { return $this->_expireQueryCache; } public function free() { parent::free(); $this->_dql = null; $this->_state = self::STATE_CLEAN; } public function setDQL($dqlQuery) : self { if ($dqlQuery !== null) { $this->_dql = $dqlQuery; $this->_state = self::STATE_DIRTY; } return $this; } public function getDQL() { return $this->_dql; } public function getState() { return $this->_state; } public function contains($dql) { return \stripos($this->getDQL(), $dql) !== \false; } public function setFirstResult($firstResult) : self { $this->_firstResult = $firstResult; $this->_state = self::STATE_DIRTY; return $this; } public function getFirstResult() { return $this->_firstResult; } public function setMaxResults($maxResults) : self { $this->_maxResults = $maxResults; $this->_state = self::STATE_DIRTY; return $this; } public function getMaxResults() { return $this->_maxResults; } public function iterate($parameters = null, $hydrationMode = self::HYDRATE_OBJECT) { $this->setHint(self::HINT_INTERNAL_ITERATION, \true); return parent::iterate($parameters, $hydrationMode); } public function setHint($name, $value) { $this->_state = self::STATE_DIRTY; return parent::setHint($name, $value); } public function setHydrationMode($hydrationMode) { $this->_state = self::STATE_DIRTY; return parent::setHydrationMode($hydrationMode); } public function setLockMode($lockMode) : self { if (\in_array($lockMode, [\MailPoetVendor\Doctrine\DBAL\LockMode::NONE, \MailPoetVendor\Doctrine\DBAL\LockMode::PESSIMISTIC_READ, \MailPoetVendor\Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE], \true)) { if (!$this->_em->getConnection()->isTransactionActive()) { throw \MailPoetVendor\Doctrine\ORM\TransactionRequiredException::transactionRequired(); } } $this->setHint(self::HINT_LOCK_MODE, $lockMode); return $this; } public function getLockMode() { $lockMode = $this->getHint(self::HINT_LOCK_MODE); if (\false === $lockMode) { return null; } return $lockMode; } protected function _getQueryCacheId() { \ksort($this->_hints); $platform = $this->getEntityManager()->getConnection()->getDatabasePlatform()->getName(); return \md5($this->getDQL() . \serialize($this->_hints) . '&platform=' . $platform . ($this->_em->hasFilters() ? $this->_em->getFilters()->getHash() : '') . '&firstResult=' . $this->_firstResult . '&maxResult=' . $this->_maxResults . '&hydrationMode=' . $this->_hydrationMode . '&types=' . \serialize($this->_parsedTypes) . 'DOCTRINE_QUERY_CACHE_SALT'); } protected function getHash() { return \sha1(parent::getHash() . '-' . $this->_firstResult . '-' . $this->_maxResults); } public function __clone() { parent::__clone(); $this->_state = self::STATE_DIRTY; } } 