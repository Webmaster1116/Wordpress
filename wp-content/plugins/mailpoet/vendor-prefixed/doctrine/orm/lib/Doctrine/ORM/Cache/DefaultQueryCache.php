<?php
 namespace MailPoetVendor\Doctrine\ORM\Cache; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\Common\Collections\ArrayCollection; use MailPoetVendor\Doctrine\ORM\Cache\Persister\CachedPersister; use MailPoetVendor\Doctrine\ORM\Cache\Persister\Entity\CachedEntityPersister; use MailPoetVendor\Doctrine\ORM\EntityManagerInterface; use MailPoetVendor\Doctrine\ORM\Query\ResultSetMapping; use MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata; use MailPoetVendor\Doctrine\ORM\PersistentCollection; use MailPoetVendor\Doctrine\Common\Proxy\Proxy; use MailPoetVendor\Doctrine\ORM\Cache; use MailPoetVendor\Doctrine\ORM\Query; use function assert; class DefaultQueryCache implements \MailPoetVendor\Doctrine\ORM\Cache\QueryCache { private $em; private $uow; private $region; private $validator; protected $cacheLogger; private static $hints = [\MailPoetVendor\Doctrine\ORM\Query::HINT_CACHE_ENABLED => \true]; public function __construct(\MailPoetVendor\Doctrine\ORM\EntityManagerInterface $em, \MailPoetVendor\Doctrine\ORM\Cache\Region $region) { $cacheConfig = $em->getConfiguration()->getSecondLevelCacheConfiguration(); $this->em = $em; $this->region = $region; $this->uow = $em->getUnitOfWork(); $this->cacheLogger = $cacheConfig->getCacheLogger(); $this->validator = $cacheConfig->getQueryValidator(); } public function get(\MailPoetVendor\Doctrine\ORM\Cache\QueryCacheKey $key, \MailPoetVendor\Doctrine\ORM\Query\ResultSetMapping $rsm, array $hints = []) { if (!($key->cacheMode & \MailPoetVendor\Doctrine\ORM\Cache::MODE_GET)) { return null; } $cacheEntry = $this->region->get($key); if (!$cacheEntry instanceof \MailPoetVendor\Doctrine\ORM\Cache\QueryCacheEntry) { return null; } if (!$this->validator->isValid($key, $cacheEntry)) { $this->region->evict($key); return null; } $result = []; $entityName = \reset($rsm->aliasMap); $hasRelation = !empty($rsm->relationMap); $persister = $this->uow->getEntityPersister($entityName); \assert($persister instanceof \MailPoetVendor\Doctrine\ORM\Cache\Persister\Entity\CachedEntityPersister); $region = $persister->getCacheRegion(); $regionName = $region->getName(); $cm = $this->em->getClassMetadata($entityName); $generateKeys = static function (array $entry) use($cm) : EntityCacheKey { return new \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey($cm->rootEntityName, $entry['identifier']); }; $cacheKeys = new \MailPoetVendor\Doctrine\ORM\Cache\CollectionCacheEntry(\array_map($generateKeys, $cacheEntry->result)); $entries = $region->getMultiple($cacheKeys) ?? []; foreach ($cacheEntry->result as $index => $entry) { $entityEntry = $entries[$index] ?? null; if (!$entityEntry instanceof \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheEntry) { if ($this->cacheLogger !== null) { $this->cacheLogger->entityCacheMiss($regionName, $cacheKeys->identifiers[$index]); } return null; } if ($this->cacheLogger !== null) { $this->cacheLogger->entityCacheHit($regionName, $cacheKeys->identifiers[$index]); } if (!$hasRelation) { $result[$index] = $this->uow->createEntity($entityEntry->class, $entityEntry->resolveAssociationEntries($this->em), self::$hints); continue; } $data = $entityEntry->data; foreach ($entry['associations'] as $name => $assoc) { $assocPersister = $this->uow->getEntityPersister($assoc['targetEntity']); \assert($assocPersister instanceof \MailPoetVendor\Doctrine\ORM\Cache\Persister\Entity\CachedEntityPersister); $assocRegion = $assocPersister->getCacheRegion(); $assocMetadata = $this->em->getClassMetadata($assoc['targetEntity']); if ($assoc['type'] & \MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata::TO_ONE) { if (($assocEntry = $assocRegion->get($assocKey = new \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey($assocMetadata->rootEntityName, $assoc['identifier']))) === null) { if ($this->cacheLogger !== null) { $this->cacheLogger->entityCacheMiss($assocRegion->getName(), $assocKey); } $this->uow->hydrationComplete(); return null; } $data[$name] = $this->uow->createEntity($assocEntry->class, $assocEntry->resolveAssociationEntries($this->em), self::$hints); if ($this->cacheLogger !== null) { $this->cacheLogger->entityCacheHit($assocRegion->getName(), $assocKey); } continue; } if (!isset($assoc['list']) || empty($assoc['list'])) { continue; } $generateKeys = function ($id) use($assocMetadata) : EntityCacheKey { return new \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey($assocMetadata->rootEntityName, $id); }; $collection = new \MailPoetVendor\Doctrine\ORM\PersistentCollection($this->em, $assocMetadata, new \MailPoetVendor\Doctrine\Common\Collections\ArrayCollection()); $assocKeys = new \MailPoetVendor\Doctrine\ORM\Cache\CollectionCacheEntry(\array_map($generateKeys, $assoc['list'])); $assocEntries = $assocRegion->getMultiple($assocKeys); foreach ($assoc['list'] as $assocIndex => $assocId) { $assocEntry = \is_array($assocEntries) && \array_key_exists($assocIndex, $assocEntries) ? $assocEntries[$assocIndex] : null; if ($assocEntry === null) { if ($this->cacheLogger !== null) { $this->cacheLogger->entityCacheMiss($assocRegion->getName(), $assocKeys->identifiers[$assocIndex]); } $this->uow->hydrationComplete(); return null; } $element = $this->uow->createEntity($assocEntry->class, $assocEntry->resolveAssociationEntries($this->em), self::$hints); $collection->hydrateSet($assocIndex, $element); if ($this->cacheLogger !== null) { $this->cacheLogger->entityCacheHit($assocRegion->getName(), $assocKeys->identifiers[$assocIndex]); } } $data[$name] = $collection; $collection->setInitialized(\true); } foreach ($data as $fieldName => $unCachedAssociationData) { if ($unCachedAssociationData instanceof \MailPoetVendor\Doctrine\ORM\Cache\AssociationCacheEntry) { $data[$fieldName] = $this->em->getReference($unCachedAssociationData->class, $unCachedAssociationData->identifier); } } $result[$index] = $this->uow->createEntity($entityEntry->class, $data, self::$hints); } $this->uow->hydrationComplete(); return $result; } public function put(\MailPoetVendor\Doctrine\ORM\Cache\QueryCacheKey $key, \MailPoetVendor\Doctrine\ORM\Query\ResultSetMapping $rsm, $result, array $hints = []) { if ($rsm->scalarMappings) { throw new \MailPoetVendor\Doctrine\ORM\Cache\CacheException("Second level cache does not support scalar results."); } if (\count($rsm->entityMappings) > 1) { throw new \MailPoetVendor\Doctrine\ORM\Cache\CacheException("Second level cache does not support multiple root entities."); } if (!$rsm->isSelect) { throw new \MailPoetVendor\Doctrine\ORM\Cache\CacheException("Second-level cache query supports only select statements."); } if (($hints[\MailPoetVendor\Doctrine\ORM\Query\SqlWalker::HINT_PARTIAL] ?? \false) === \true || ($hints[\MailPoetVendor\Doctrine\ORM\Query::HINT_FORCE_PARTIAL_LOAD] ?? \false) === \true) { throw new \MailPoetVendor\Doctrine\ORM\Cache\CacheException("Second level cache does not support partial entities."); } if (!($key->cacheMode & \MailPoetVendor\Doctrine\ORM\Cache::MODE_PUT)) { return \false; } $data = []; $entityName = \reset($rsm->aliasMap); $rootAlias = \key($rsm->aliasMap); $persister = $this->uow->getEntityPersister($entityName); if (!$persister instanceof \MailPoetVendor\Doctrine\ORM\Cache\Persister\Entity\CachedEntityPersister) { throw \MailPoetVendor\Doctrine\ORM\Cache\CacheException::nonCacheableEntity($entityName); } $region = $persister->getCacheRegion(); $cm = $this->em->getClassMetadata($entityName); \assert($cm instanceof \MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata); foreach ($result as $index => $entity) { $identifier = $this->uow->getEntityIdentifier($entity); $entityKey = new \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey($cm->rootEntityName, $identifier); if ($key->cacheMode & \MailPoetVendor\Doctrine\ORM\Cache::MODE_REFRESH || !$region->contains($entityKey)) { if (!$persister->storeEntityCache($entity, $entityKey)) { return \false; } } $data[$index]['identifier'] = $identifier; $data[$index]['associations'] = []; foreach ($rsm->relationMap as $alias => $name) { $parentAlias = $rsm->parentAliasMap[$alias]; $parentClass = $rsm->aliasMap[$parentAlias]; $metadata = $this->em->getClassMetadata($parentClass); $assoc = $metadata->associationMappings[$name]; $assocValue = $this->getAssociationValue($rsm, $alias, $entity); if ($assocValue === null) { continue; } if ($rootAlias === $parentAlias) { if (($assocInfo = $this->storeAssociationCache($key, $assoc, $assocValue)) === null) { return \false; } $data[$index]['associations'][$name] = $assocInfo; continue; } if (!\is_array($assocValue)) { if ($this->storeAssociationCache($key, $assoc, $assocValue) === null) { return \false; } continue; } foreach ($assocValue as $aVal) { if ($this->storeAssociationCache($key, $assoc, $aVal) === null) { return \false; } } } } return $this->region->put($key, new \MailPoetVendor\Doctrine\ORM\Cache\QueryCacheEntry($data)); } private function storeAssociationCache(\MailPoetVendor\Doctrine\ORM\Cache\QueryCacheKey $key, array $assoc, $assocValue) { $assocPersister = $this->uow->getEntityPersister($assoc['targetEntity']); $assocMetadata = $assocPersister->getClassMetadata(); $assocRegion = $assocPersister->getCacheRegion(); if ($assoc['type'] & \MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata::TO_ONE) { $assocIdentifier = $this->uow->getEntityIdentifier($assocValue); $entityKey = new \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey($assocMetadata->rootEntityName, $assocIdentifier); if (!$assocValue instanceof \MailPoetVendor\Doctrine\Common\Proxy\Proxy && $key->cacheMode & \MailPoetVendor\Doctrine\ORM\Cache::MODE_REFRESH || !$assocRegion->contains($entityKey)) { if (!$assocPersister->storeEntityCache($assocValue, $entityKey)) { return null; } } return ['targetEntity' => $assocMetadata->rootEntityName, 'identifier' => $assocIdentifier, 'type' => $assoc['type']]; } $list = []; foreach ($assocValue as $assocItemIndex => $assocItem) { $assocIdentifier = $this->uow->getEntityIdentifier($assocItem); $entityKey = new \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey($assocMetadata->rootEntityName, $assocIdentifier); if ($key->cacheMode & \MailPoetVendor\Doctrine\ORM\Cache::MODE_REFRESH || !$assocRegion->contains($entityKey)) { if (!$assocPersister->storeEntityCache($assocItem, $entityKey)) { return null; } } $list[$assocItemIndex] = $assocIdentifier; } return ['targetEntity' => $assocMetadata->rootEntityName, 'type' => $assoc['type'], 'list' => $list]; } private function getAssociationValue(\MailPoetVendor\Doctrine\ORM\Query\ResultSetMapping $rsm, $assocAlias, $entity) { $path = []; $alias = $assocAlias; while (isset($rsm->parentAliasMap[$alias])) { $parent = $rsm->parentAliasMap[$alias]; $field = $rsm->relationMap[$alias]; $class = $rsm->aliasMap[$parent]; \array_unshift($path, ['field' => $field, 'class' => $class]); $alias = $parent; } return $this->getAssociationPathValue($entity, $path); } private function getAssociationPathValue($value, array $path) { $mapping = \array_shift($path); $metadata = $this->em->getClassMetadata($mapping['class']); $assoc = $metadata->associationMappings[$mapping['field']]; $value = $metadata->getFieldValue($value, $mapping['field']); if ($value === null) { return null; } if (empty($path)) { return $value; } if ($assoc['type'] & \MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata::TO_ONE) { return $this->getAssociationPathValue($value, $path); } $values = []; foreach ($value as $item) { $values[] = $this->getAssociationPathValue($item, $path); } return $values; } public function clear() { return $this->region->evictAll(); } public function getRegion() { return $this->region; } } 