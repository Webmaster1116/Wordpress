<?php
 namespace MailPoetVendor\Doctrine\ORM\Cache; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\ORM\Query; use MailPoetVendor\Doctrine\ORM\PersistentCollection; use MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata; use MailPoetVendor\Doctrine\ORM\EntityManagerInterface; class DefaultCollectionHydrator implements \MailPoetVendor\Doctrine\ORM\Cache\CollectionHydrator { private $em; private $uow; private static $hints = [\MailPoetVendor\Doctrine\ORM\Query::HINT_CACHE_ENABLED => \true]; public function __construct(\MailPoetVendor\Doctrine\ORM\EntityManagerInterface $em) { $this->em = $em; $this->uow = $em->getUnitOfWork(); } public function buildCacheEntry(\MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata $metadata, \MailPoetVendor\Doctrine\ORM\Cache\CollectionCacheKey $key, $collection) { $data = []; foreach ($collection as $index => $entity) { $data[$index] = new \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey($metadata->rootEntityName, $this->uow->getEntityIdentifier($entity)); } return new \MailPoetVendor\Doctrine\ORM\Cache\CollectionCacheEntry($data); } public function loadCacheEntry(\MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata $metadata, \MailPoetVendor\Doctrine\ORM\Cache\CollectionCacheKey $key, \MailPoetVendor\Doctrine\ORM\Cache\CollectionCacheEntry $entry, \MailPoetVendor\Doctrine\ORM\PersistentCollection $collection) { $assoc = $metadata->associationMappings[$key->association]; $targetPersister = $this->uow->getEntityPersister($assoc['targetEntity']); $targetRegion = $targetPersister->getCacheRegion(); $list = []; $entityEntries = $targetRegion->getMultiple($entry); if ($entityEntries === null) { return null; } foreach ($entityEntries as $index => $entityEntry) { $list[$index] = $this->uow->createEntity($entityEntry->class, $entityEntry->resolveAssociationEntries($this->em), self::$hints); } \array_walk($list, function ($entity, $index) use($collection) { $collection->hydrateSet($index, $entity); }); $this->uow->hydrationComplete(); return $list; } } 