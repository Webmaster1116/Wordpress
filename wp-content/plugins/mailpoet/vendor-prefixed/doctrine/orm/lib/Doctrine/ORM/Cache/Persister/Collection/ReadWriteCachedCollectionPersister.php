<?php
 namespace MailPoetVendor\Doctrine\ORM\Cache\Persister\Collection; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\ORM\Persisters\Collection\CollectionPersister; use MailPoetVendor\Doctrine\ORM\EntityManagerInterface; use MailPoetVendor\Doctrine\ORM\Cache\CollectionCacheKey; use MailPoetVendor\Doctrine\ORM\Cache\ConcurrentRegion; use MailPoetVendor\Doctrine\ORM\PersistentCollection; class ReadWriteCachedCollectionPersister extends \MailPoetVendor\Doctrine\ORM\Cache\Persister\Collection\AbstractCollectionPersister { public function __construct(\MailPoetVendor\Doctrine\ORM\Persisters\Collection\CollectionPersister $persister, \MailPoetVendor\Doctrine\ORM\Cache\ConcurrentRegion $region, \MailPoetVendor\Doctrine\ORM\EntityManagerInterface $em, array $association) { parent::__construct($persister, $region, $em, $association); } public function afterTransactionComplete() { if (isset($this->queuedCache['update'])) { foreach ($this->queuedCache['update'] as $item) { $this->region->evict($item['key']); } } if (isset($this->queuedCache['delete'])) { foreach ($this->queuedCache['delete'] as $item) { $this->region->evict($item['key']); } } $this->queuedCache = []; } public function afterTransactionRolledBack() { if (isset($this->queuedCache['update'])) { foreach ($this->queuedCache['update'] as $item) { $this->region->evict($item['key']); } } if (isset($this->queuedCache['delete'])) { foreach ($this->queuedCache['delete'] as $item) { $this->region->evict($item['key']); } } $this->queuedCache = []; } public function delete(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection) { $ownerId = $this->uow->getEntityIdentifier($collection->getOwner()); $key = new \MailPoetVendor\Doctrine\ORM\Cache\CollectionCacheKey($this->sourceEntity->rootEntityName, $this->association['fieldName'], $ownerId); $lock = $this->region->lock($key); $this->persister->delete($collection); if ($lock === null) { return; } $this->queuedCache['delete'][\spl_object_hash($collection)] = ['key' => $key, 'lock' => $lock]; } public function update(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection) { $isInitialized = $collection->isInitialized(); $isDirty = $collection->isDirty(); if (!$isInitialized && !$isDirty) { return; } $this->persister->update($collection); $ownerId = $this->uow->getEntityIdentifier($collection->getOwner()); $key = new \MailPoetVendor\Doctrine\ORM\Cache\CollectionCacheKey($this->sourceEntity->rootEntityName, $this->association['fieldName'], $ownerId); $lock = $this->region->lock($key); if ($lock === null) { return; } $this->queuedCache['update'][\spl_object_hash($collection)] = ['key' => $key, 'lock' => $lock]; } } 