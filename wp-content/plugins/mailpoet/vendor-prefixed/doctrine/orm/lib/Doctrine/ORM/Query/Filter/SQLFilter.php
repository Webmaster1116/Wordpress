<?php
 namespace MailPoetVendor\Doctrine\ORM\Query\Filter; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\ORM\EntityManagerInterface; use MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata; use MailPoetVendor\Doctrine\ORM\Query\ParameterTypeInferer; abstract class SQLFilter { private $em; private $parameters = []; public final function __construct(\MailPoetVendor\Doctrine\ORM\EntityManagerInterface $em) { $this->em = $em; } public final function setParameter($name, $value, $type = null) : self { if (null === $type) { $type = \MailPoetVendor\Doctrine\ORM\Query\ParameterTypeInferer::inferType($value); } $this->parameters[$name] = ['value' => $value, 'type' => $type]; \ksort($this->parameters); $this->em->getFilters()->setFiltersStateDirty(); return $this; } public final function getParameter($name) { if (!isset($this->parameters[$name])) { throw new \InvalidArgumentException("Parameter '" . $name . "' does not exist."); } return $this->em->getConnection()->quote($this->parameters[$name]['value'], $this->parameters[$name]['type']); } public final function hasParameter($name) { if (!isset($this->parameters[$name])) { return \false; } return \true; } public final function __toString() { return \serialize($this->parameters); } protected final function getConnection() { return $this->em->getConnection(); } public abstract function addFilterConstraint(\MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata $targetEntity, $targetTableAlias); } 