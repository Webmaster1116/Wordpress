<?php
 namespace MailPoetVendor\Doctrine\ORM\Mapping\Builder; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\ORM\Mapping\MappingException; use MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata; use MailPoetVendor\Doctrine\ORM\Events; class EntityListenerBuilder { private static $events = [\MailPoetVendor\Doctrine\ORM\Events::preRemove => \true, \MailPoetVendor\Doctrine\ORM\Events::postRemove => \true, \MailPoetVendor\Doctrine\ORM\Events::prePersist => \true, \MailPoetVendor\Doctrine\ORM\Events::postPersist => \true, \MailPoetVendor\Doctrine\ORM\Events::preUpdate => \true, \MailPoetVendor\Doctrine\ORM\Events::postUpdate => \true, \MailPoetVendor\Doctrine\ORM\Events::postLoad => \true, \MailPoetVendor\Doctrine\ORM\Events::preFlush => \true]; public static function bindEntityListener(\MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata $metadata, $className) { $class = $metadata->fullyQualifiedClassName($className); if (!\class_exists($class)) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::entityListenerClassNotFound($class, $className); } foreach (\get_class_methods($class) as $method) { if (!isset(self::$events[$method])) { continue; } $metadata->addEntityListener($method, $class, $method); } } } 