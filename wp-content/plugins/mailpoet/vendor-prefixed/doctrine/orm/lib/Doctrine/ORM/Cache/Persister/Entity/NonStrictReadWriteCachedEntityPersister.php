<?php
 namespace MailPoetVendor\Doctrine\ORM\Cache\Persister\Entity; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey; class NonStrictReadWriteCachedEntityPersister extends \MailPoetVendor\Doctrine\ORM\Cache\Persister\Entity\AbstractEntityPersister { public function afterTransactionComplete() { $isChanged = \false; if (isset($this->queuedCache['insert'])) { foreach ($this->queuedCache['insert'] as $entity) { $isChanged = $this->updateCache($entity, $isChanged); } } if (isset($this->queuedCache['update'])) { foreach ($this->queuedCache['update'] as $entity) { $isChanged = $this->updateCache($entity, $isChanged); } } if (isset($this->queuedCache['delete'])) { foreach ($this->queuedCache['delete'] as $key) { $this->region->evict($key); $isChanged = \true; } } if ($isChanged) { $this->timestampRegion->update($this->timestampKey); } $this->queuedCache = []; } public function afterTransactionRolledBack() { $this->queuedCache = []; } public function delete($entity) { $key = new \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey($this->class->rootEntityName, $this->uow->getEntityIdentifier($entity)); $deleted = $this->persister->delete($entity); if ($deleted) { $this->region->evict($key); } $this->queuedCache['delete'][] = $key; return $deleted; } public function update($entity) { $this->persister->update($entity); $this->queuedCache['update'][] = $entity; } private function updateCache($entity, $isChanged) { $class = $this->metadataFactory->getMetadataFor(\get_class($entity)); $key = new \MailPoetVendor\Doctrine\ORM\Cache\EntityCacheKey($class->rootEntityName, $this->uow->getEntityIdentifier($entity)); $entry = $this->hydrator->buildCacheEntry($class, $key, $entity); $cached = $this->region->put($key, $entry); $isChanged = $isChanged ?: $cached; if ($this->cacheLogger && $cached) { $this->cacheLogger->entityCachePut($this->regionName, $key); } return $isChanged; } } 