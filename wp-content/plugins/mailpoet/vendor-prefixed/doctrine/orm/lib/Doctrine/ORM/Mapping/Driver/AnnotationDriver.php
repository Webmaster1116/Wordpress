<?php
 namespace MailPoetVendor\Doctrine\ORM\Mapping\Driver; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\Common\Annotations\AnnotationReader; use MailPoetVendor\Doctrine\ORM\Events; use MailPoetVendor\Doctrine\ORM\Mapping; use MailPoetVendor\Doctrine\ORM\Mapping\Builder\EntityListenerBuilder; use MailPoetVendor\Doctrine\ORM\Mapping\MappingException; use MailPoetVendor\Doctrine\Persistence\Mapping\ClassMetadata; use MailPoetVendor\Doctrine\Persistence\Mapping\Driver\AnnotationDriver as AbstractAnnotationDriver; use function interface_exists; class AnnotationDriver extends \MailPoetVendor\Doctrine\Persistence\Mapping\Driver\AnnotationDriver { protected $entityAnnotationClasses = [\MailPoetVendor\Doctrine\ORM\Mapping\Entity::class => 1, \MailPoetVendor\Doctrine\ORM\Mapping\MappedSuperclass::class => 2]; public function loadMetadataForClass($className, \MailPoetVendor\Doctrine\Persistence\Mapping\ClassMetadata $metadata) { $class = $metadata->getReflectionClass(); if (!$class) { $class = new \ReflectionClass($metadata->name); } $classAnnotations = $this->reader->getClassAnnotations($class); if ($classAnnotations) { foreach ($classAnnotations as $key => $annot) { if (!\is_numeric($key)) { continue; } $classAnnotations[\get_class($annot)] = $annot; } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Entity::class])) { $entityAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Entity::class]; if ($entityAnnot->repositoryClass !== null) { $metadata->setCustomRepositoryClass($entityAnnot->repositoryClass); } if ($entityAnnot->readOnly) { $metadata->markReadOnly(); } } else { if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\MappedSuperclass::class])) { $mappedSuperclassAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\MappedSuperclass::class]; $metadata->setCustomRepositoryClass($mappedSuperclassAnnot->repositoryClass); $metadata->isMappedSuperclass = \true; } else { if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Embeddable::class])) { $metadata->isEmbeddedClass = \true; } else { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::classIsNotAValidEntityOrMappedSuperClass($className); } } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Table::class])) { $tableAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Table::class]; $primaryTable = ['name' => $tableAnnot->name, 'schema' => $tableAnnot->schema]; if ($tableAnnot->indexes !== null) { foreach ($tableAnnot->indexes as $indexAnnot) { $index = ['columns' => $indexAnnot->columns]; if (!empty($indexAnnot->flags)) { $index['flags'] = $indexAnnot->flags; } if (!empty($indexAnnot->options)) { $index['options'] = $indexAnnot->options; } if (!empty($indexAnnot->name)) { $primaryTable['indexes'][$indexAnnot->name] = $index; } else { $primaryTable['indexes'][] = $index; } } } if ($tableAnnot->uniqueConstraints !== null) { foreach ($tableAnnot->uniqueConstraints as $uniqueConstraintAnnot) { $uniqueConstraint = ['columns' => $uniqueConstraintAnnot->columns]; if (!empty($uniqueConstraintAnnot->options)) { $uniqueConstraint['options'] = $uniqueConstraintAnnot->options; } if (!empty($uniqueConstraintAnnot->name)) { $primaryTable['uniqueConstraints'][$uniqueConstraintAnnot->name] = $uniqueConstraint; } else { $primaryTable['uniqueConstraints'][] = $uniqueConstraint; } } } if ($tableAnnot->options) { $primaryTable['options'] = $tableAnnot->options; } $metadata->setPrimaryTable($primaryTable); } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Cache::class])) { $cacheAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\Cache::class]; $cacheMap = ['region' => $cacheAnnot->region, 'usage' => \constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::CACHE_USAGE_' . $cacheAnnot->usage)]; $metadata->enableCache($cacheMap); } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\NamedNativeQueries::class])) { $namedNativeQueriesAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\NamedNativeQueries::class]; foreach ($namedNativeQueriesAnnot->value as $namedNativeQuery) { $metadata->addNamedNativeQuery(['name' => $namedNativeQuery->name, 'query' => $namedNativeQuery->query, 'resultClass' => $namedNativeQuery->resultClass, 'resultSetMapping' => $namedNativeQuery->resultSetMapping]); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\SqlResultSetMappings::class])) { $sqlResultSetMappingsAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\SqlResultSetMappings::class]; foreach ($sqlResultSetMappingsAnnot->value as $resultSetMapping) { $entities = []; $columns = []; foreach ($resultSetMapping->entities as $entityResultAnnot) { $entityResult = ['fields' => [], 'entityClass' => $entityResultAnnot->entityClass, 'discriminatorColumn' => $entityResultAnnot->discriminatorColumn]; foreach ($entityResultAnnot->fields as $fieldResultAnnot) { $entityResult['fields'][] = ['name' => $fieldResultAnnot->name, 'column' => $fieldResultAnnot->column]; } $entities[] = $entityResult; } foreach ($resultSetMapping->columns as $columnResultAnnot) { $columns[] = ['name' => $columnResultAnnot->name]; } $metadata->addSqlResultSetMapping(['name' => $resultSetMapping->name, 'entities' => $entities, 'columns' => $columns]); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\NamedQueries::class])) { $namedQueriesAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\NamedQueries::class]; if (!\is_array($namedQueriesAnnot->value)) { throw new \UnexpectedValueException("@NamedQueries should contain an array of @NamedQuery annotations."); } foreach ($namedQueriesAnnot->value as $namedQuery) { if (!$namedQuery instanceof \MailPoetVendor\Doctrine\ORM\Mapping\NamedQuery) { throw new \UnexpectedValueException("@NamedQueries should contain an array of @NamedQuery annotations."); } $metadata->addNamedQuery(['name' => $namedQuery->name, 'query' => $namedQuery->query]); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\InheritanceType::class])) { $inheritanceTypeAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\InheritanceType::class]; $metadata->setInheritanceType(\constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::INHERITANCE_TYPE_' . $inheritanceTypeAnnot->value)); if ($metadata->inheritanceType != \MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata::INHERITANCE_TYPE_NONE) { if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\DiscriminatorColumn::class])) { $discrColumnAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\DiscriminatorColumn::class]; $metadata->setDiscriminatorColumn(['name' => $discrColumnAnnot->name, 'type' => $discrColumnAnnot->type ?: 'string', 'length' => $discrColumnAnnot->length ?: 255, 'columnDefinition' => $discrColumnAnnot->columnDefinition]); } else { $metadata->setDiscriminatorColumn(['name' => 'dtype', 'type' => 'string', 'length' => 255]); } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\DiscriminatorMap::class])) { $discrMapAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\DiscriminatorMap::class]; $metadata->setDiscriminatorMap($discrMapAnnot->value); } } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\ChangeTrackingPolicy::class])) { $changeTrackingAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\ChangeTrackingPolicy::class]; $metadata->setChangeTrackingPolicy(\constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::CHANGETRACKING_' . $changeTrackingAnnot->value)); } foreach ($class->getProperties() as $property) { if ($metadata->isMappedSuperclass && !$property->isPrivate() || $metadata->isInheritedField($property->name) || $metadata->isInheritedAssociation($property->name) || $metadata->isInheritedEmbeddedClass($property->name)) { continue; } $mapping = []; $mapping['fieldName'] = $property->getName(); if (($cacheAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Cache::class)) !== null) { $mapping['cache'] = $metadata->getAssociationCacheDefaults($mapping['fieldName'], ['usage' => \constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::CACHE_USAGE_' . $cacheAnnot->usage), 'region' => $cacheAnnot->region]); } $joinColumns = []; if ($joinColumnAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\JoinColumn::class)) { $joinColumns[] = $this->joinColumnToArray($joinColumnAnnot); } else { if ($joinColumnsAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\JoinColumns::class)) { foreach ($joinColumnsAnnot->value as $joinColumn) { $joinColumns[] = $this->joinColumnToArray($joinColumn); } } } if ($columnAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Column::class)) { if ($columnAnnot->type == null) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::propertyTypeIsRequired($className, $property->getName()); } $mapping = $this->columnToArray($property->getName(), $columnAnnot); if ($idAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Id::class)) { $mapping['id'] = \true; } if ($generatedValueAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\GeneratedValue::class)) { $metadata->setIdGeneratorType(\constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::GENERATOR_TYPE_' . $generatedValueAnnot->strategy)); } if ($this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Version::class)) { $metadata->setVersionMapping($mapping); } $metadata->mapField($mapping); if ($seqGeneratorAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\SequenceGenerator::class)) { $metadata->setSequenceGeneratorDefinition(['sequenceName' => $seqGeneratorAnnot->sequenceName, 'allocationSize' => $seqGeneratorAnnot->allocationSize, 'initialValue' => $seqGeneratorAnnot->initialValue]); } else { if ($this->reader->getPropertyAnnotation($property, 'MailPoetVendor\\Doctrine\\ORM\\Mapping\\TableGenerator')) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::tableIdGeneratorNotImplemented($className); } else { if ($customGeneratorAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\CustomIdGenerator::class)) { $metadata->setCustomGeneratorDefinition(['class' => $customGeneratorAnnot->class]); } } } } else { if ($oneToOneAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\OneToOne::class)) { if ($idAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Id::class)) { $mapping['id'] = \true; } $mapping['targetEntity'] = $oneToOneAnnot->targetEntity; $mapping['joinColumns'] = $joinColumns; $mapping['mappedBy'] = $oneToOneAnnot->mappedBy; $mapping['inversedBy'] = $oneToOneAnnot->inversedBy; $mapping['cascade'] = $oneToOneAnnot->cascade; $mapping['orphanRemoval'] = $oneToOneAnnot->orphanRemoval; $mapping['fetch'] = $this->getFetchMode($className, $oneToOneAnnot->fetch); $metadata->mapOneToOne($mapping); } else { if ($oneToManyAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\OneToMany::class)) { $mapping['mappedBy'] = $oneToManyAnnot->mappedBy; $mapping['targetEntity'] = $oneToManyAnnot->targetEntity; $mapping['cascade'] = $oneToManyAnnot->cascade; $mapping['indexBy'] = $oneToManyAnnot->indexBy; $mapping['orphanRemoval'] = $oneToManyAnnot->orphanRemoval; $mapping['fetch'] = $this->getFetchMode($className, $oneToManyAnnot->fetch); if ($orderByAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\OrderBy::class)) { $mapping['orderBy'] = $orderByAnnot->value; } $metadata->mapOneToMany($mapping); } else { if ($manyToOneAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\ManyToOne::class)) { if ($idAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Id::class)) { $mapping['id'] = \true; } $mapping['joinColumns'] = $joinColumns; $mapping['cascade'] = $manyToOneAnnot->cascade; $mapping['inversedBy'] = $manyToOneAnnot->inversedBy; $mapping['targetEntity'] = $manyToOneAnnot->targetEntity; $mapping['fetch'] = $this->getFetchMode($className, $manyToOneAnnot->fetch); $metadata->mapManyToOne($mapping); } else { if ($manyToManyAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\ManyToMany::class)) { $joinTable = []; if ($joinTableAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\JoinTable::class)) { $joinTable = ['name' => $joinTableAnnot->name, 'schema' => $joinTableAnnot->schema]; foreach ($joinTableAnnot->joinColumns as $joinColumn) { $joinTable['joinColumns'][] = $this->joinColumnToArray($joinColumn); } foreach ($joinTableAnnot->inverseJoinColumns as $joinColumn) { $joinTable['inverseJoinColumns'][] = $this->joinColumnToArray($joinColumn); } } $mapping['joinTable'] = $joinTable; $mapping['targetEntity'] = $manyToManyAnnot->targetEntity; $mapping['mappedBy'] = $manyToManyAnnot->mappedBy; $mapping['inversedBy'] = $manyToManyAnnot->inversedBy; $mapping['cascade'] = $manyToManyAnnot->cascade; $mapping['indexBy'] = $manyToManyAnnot->indexBy; $mapping['orphanRemoval'] = $manyToManyAnnot->orphanRemoval; $mapping['fetch'] = $this->getFetchMode($className, $manyToManyAnnot->fetch); if ($orderByAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\OrderBy::class)) { $mapping['orderBy'] = $orderByAnnot->value; } $metadata->mapManyToMany($mapping); } else { if ($embeddedAnnot = $this->reader->getPropertyAnnotation($property, \MailPoetVendor\Doctrine\ORM\Mapping\Embedded::class)) { $mapping['class'] = $embeddedAnnot->class; $mapping['columnPrefix'] = $embeddedAnnot->columnPrefix; $metadata->mapEmbedded($mapping); } } } } } } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\AssociationOverrides::class])) { $associationOverridesAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\AssociationOverrides::class]; foreach ($associationOverridesAnnot->value as $associationOverride) { $override = []; $fieldName = $associationOverride->name; if ($associationOverride->joinColumns) { $joinColumns = []; foreach ($associationOverride->joinColumns as $joinColumn) { $joinColumns[] = $this->joinColumnToArray($joinColumn); } $override['joinColumns'] = $joinColumns; } if ($associationOverride->joinTable) { $joinTableAnnot = $associationOverride->joinTable; $joinTable = ['name' => $joinTableAnnot->name, 'schema' => $joinTableAnnot->schema]; foreach ($joinTableAnnot->joinColumns as $joinColumn) { $joinTable['joinColumns'][] = $this->joinColumnToArray($joinColumn); } foreach ($joinTableAnnot->inverseJoinColumns as $joinColumn) { $joinTable['inverseJoinColumns'][] = $this->joinColumnToArray($joinColumn); } $override['joinTable'] = $joinTable; } if ($associationOverride->inversedBy) { $override['inversedBy'] = $associationOverride->inversedBy; } if ($associationOverride->fetch) { $override['fetch'] = \constant(\MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata::class . '::FETCH_' . $associationOverride->fetch); } $metadata->setAssociationOverride($fieldName, $override); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\AttributeOverrides::class])) { $attributeOverridesAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\AttributeOverrides::class]; foreach ($attributeOverridesAnnot->value as $attributeOverrideAnnot) { $attributeOverride = $this->columnToArray($attributeOverrideAnnot->name, $attributeOverrideAnnot->column); $metadata->setAttributeOverride($attributeOverrideAnnot->name, $attributeOverride); } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\EntityListeners::class])) { $entityListenersAnnot = $classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\EntityListeners::class]; foreach ($entityListenersAnnot->value as $item) { $listenerClassName = $metadata->fullyQualifiedClassName($item); if (!\class_exists($listenerClassName)) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::entityListenerClassNotFound($listenerClassName, $className); } $hasMapping = \false; $listenerClass = new \ReflectionClass($listenerClassName); foreach ($listenerClass->getMethods(\ReflectionMethod::IS_PUBLIC) as $method) { $callbacks = $this->getMethodCallbacks($method); $hasMapping = $hasMapping ?: !empty($callbacks); foreach ($callbacks as $value) { $metadata->addEntityListener($value[1], $listenerClassName, $value[0]); } } if (!$hasMapping) { \MailPoetVendor\Doctrine\ORM\Mapping\Builder\EntityListenerBuilder::bindEntityListener($metadata, $listenerClassName); } } } if (isset($classAnnotations[\MailPoetVendor\Doctrine\ORM\Mapping\HasLifecycleCallbacks::class])) { foreach ($class->getMethods(\ReflectionMethod::IS_PUBLIC) as $method) { foreach ($this->getMethodCallbacks($method) as $value) { $metadata->addLifecycleCallback($value[0], $value[1]); } } } } private function getFetchMode($className, $fetchMode) { if (!\defined('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::FETCH_' . $fetchMode)) { throw \MailPoetVendor\Doctrine\ORM\Mapping\MappingException::invalidFetchMode($className, $fetchMode); } return \constant('MailPoetVendor\\Doctrine\\ORM\\Mapping\\ClassMetadata::FETCH_' . $fetchMode); } private function getMethodCallbacks(\ReflectionMethod $method) { $callbacks = []; $annotations = $this->reader->getMethodAnnotations($method); foreach ($annotations as $annot) { if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PrePersist) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::prePersist]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PostPersist) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::postPersist]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PreUpdate) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::preUpdate]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PostUpdate) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::postUpdate]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PreRemove) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::preRemove]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PostRemove) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::postRemove]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PostLoad) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::postLoad]; } if ($annot instanceof \MailPoetVendor\Doctrine\ORM\Mapping\PreFlush) { $callbacks[] = [$method->name, \MailPoetVendor\Doctrine\ORM\Events::preFlush]; } } return $callbacks; } private function joinColumnToArray(\MailPoetVendor\Doctrine\ORM\Mapping\JoinColumn $joinColumn) { return ['name' => $joinColumn->name, 'unique' => $joinColumn->unique, 'nullable' => $joinColumn->nullable, 'onDelete' => $joinColumn->onDelete, 'columnDefinition' => $joinColumn->columnDefinition, 'referencedColumnName' => $joinColumn->referencedColumnName]; } private function columnToArray($fieldName, \MailPoetVendor\Doctrine\ORM\Mapping\Column $column) { $mapping = ['fieldName' => $fieldName, 'type' => $column->type, 'scale' => $column->scale, 'length' => $column->length, 'unique' => $column->unique, 'nullable' => $column->nullable, 'precision' => $column->precision]; if ($column->options) { $mapping['options'] = $column->options; } if (isset($column->name)) { $mapping['columnName'] = $column->name; } if (isset($column->columnDefinition)) { $mapping['columnDefinition'] = $column->columnDefinition; } return $mapping; } public static function create($paths = [], \MailPoetVendor\Doctrine\Common\Annotations\AnnotationReader $reader = null) { if ($reader == null) { $reader = new \MailPoetVendor\Doctrine\Common\Annotations\AnnotationReader(); } return new self($reader, $paths); } } \interface_exists(\MailPoetVendor\Doctrine\Persistence\Mapping\ClassMetadata::class); 