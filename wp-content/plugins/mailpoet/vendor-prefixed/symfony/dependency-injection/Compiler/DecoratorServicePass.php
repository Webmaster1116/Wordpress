<?php
 namespace MailPoetVendor\Symfony\Component\DependencyInjection\Compiler; if (!defined('ABSPATH')) exit; use MailPoetVendor\Symfony\Component\DependencyInjection\Alias; use MailPoetVendor\Symfony\Component\DependencyInjection\ContainerBuilder; use MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\ServiceNotFoundException; use MailPoetVendor\Symfony\Component\DependencyInjection\Reference; class DecoratorServicePass implements \MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface { public function process(\MailPoetVendor\Symfony\Component\DependencyInjection\ContainerBuilder $container) { $definitions = new \SplPriorityQueue(); $order = \PHP_INT_MAX; foreach ($container->getDefinitions() as $id => $definition) { if (!($decorated = $definition->getDecoratedService())) { continue; } $definitions->insert([$id, $definition], [$decorated[2], --$order]); } $decoratingDefinitions = []; foreach ($definitions as list($id, $definition)) { $decoratedService = $definition->getDecoratedService(); list($inner, $renamedId) = $decoratedService; $invalidBehavior = $decoratedService[3] ?? \MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE; $definition->setDecoratedService(null); if (!$renamedId) { $renamedId = $id . '.inner'; } $definition->innerServiceId = $renamedId; $definition->decorationOnInvalid = $invalidBehavior; if ($container->hasAlias($inner)) { $alias = $container->getAlias($inner); $public = $alias->isPublic(); $private = $alias->isPrivate(); $container->setAlias($renamedId, new \MailPoetVendor\Symfony\Component\DependencyInjection\Alias((string) $alias, \false)); } elseif ($container->hasDefinition($inner)) { $decoratedDefinition = $container->getDefinition($inner); $public = $decoratedDefinition->isPublic(); $private = $decoratedDefinition->isPrivate(); $decoratedDefinition->setPublic(\false); $container->setDefinition($renamedId, $decoratedDefinition); $decoratingDefinitions[$inner] = $decoratedDefinition; } elseif (\MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::IGNORE_ON_INVALID_REFERENCE === $invalidBehavior) { $container->removeDefinition($id); continue; } elseif (\MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::NULL_ON_INVALID_REFERENCE === $invalidBehavior) { $public = $definition->isPublic(); $private = $definition->isPrivate(); } else { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\ServiceNotFoundException($inner, $id); } if (isset($decoratingDefinitions[$inner])) { $decoratingDefinition = $decoratingDefinitions[$inner]; $decoratingTags = $decoratingDefinition->getTags(); $resetTags = []; if (isset($decoratingTags['container.service_locator'])) { $resetTags = ['container.service_locator' => $decoratingTags['container.service_locator']]; unset($decoratingTags['container.service_locator']); } $definition->setTags(\array_merge($decoratingTags, $definition->getTags())); $decoratingDefinition->setTags($resetTags); $decoratingDefinitions[$inner] = $definition; } $container->setAlias($inner, $id)->setPublic($public)->setPrivate($private); } } } 