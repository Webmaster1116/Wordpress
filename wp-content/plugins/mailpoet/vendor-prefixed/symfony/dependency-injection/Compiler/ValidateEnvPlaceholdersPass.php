<?php
 namespace MailPoetVendor\Symfony\Component\DependencyInjection\Compiler; if (!defined('ABSPATH')) exit; use MailPoetVendor\Symfony\Component\Config\Definition\BaseNode; use MailPoetVendor\Symfony\Component\Config\Definition\Exception\TreeWithoutRootNodeException; use MailPoetVendor\Symfony\Component\Config\Definition\Processor; use MailPoetVendor\Symfony\Component\DependencyInjection\ContainerBuilder; use MailPoetVendor\Symfony\Component\DependencyInjection\Extension\ConfigurationExtensionInterface; use MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag; use MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBag; class ValidateEnvPlaceholdersPass implements \MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface { private static $typeFixtures = ['array' => [], 'bool' => \false, 'float' => 0.0, 'int' => 0, 'string' => '']; private $extensionConfig = []; public function process(\MailPoetVendor\Symfony\Component\DependencyInjection\ContainerBuilder $container) { $this->extensionConfig = []; if (!\class_exists(\MailPoetVendor\Symfony\Component\Config\Definition\BaseNode::class) || !($extensions = $container->getExtensions())) { return; } $resolvingBag = $container->getParameterBag(); if (!$resolvingBag instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag) { return; } $defaultBag = new \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBag($resolvingBag->all()); $envTypes = $resolvingBag->getProvidedTypes(); try { foreach ($resolvingBag->getEnvPlaceholders() + $resolvingBag->getUnusedEnvPlaceholders() as $env => $placeholders) { $values = []; if (\false === ($i = \strpos($env, ':'))) { $default = $defaultBag->has("env({$env})") ? $defaultBag->get("env({$env})") : self::$typeFixtures['string']; $defaultType = null !== $default ? self::getType($default) : 'string'; $values[$defaultType] = $default; } else { $prefix = \substr($env, 0, $i); foreach ($envTypes[$prefix] ?? ['string'] as $type) { $values[$type] = self::$typeFixtures[$type] ?? null; } } foreach ($placeholders as $placeholder) { \MailPoetVendor\Symfony\Component\Config\Definition\BaseNode::setPlaceholder($placeholder, $values); } } $processor = new \MailPoetVendor\Symfony\Component\Config\Definition\Processor(); foreach ($extensions as $name => $extension) { if (!$extension instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Extension\ConfigurationExtensionInterface || !($config = \array_filter($container->getExtensionConfig($name)))) { continue; } $config = $resolvingBag->resolveValue($config); if (null === ($configuration = $extension->getConfiguration($config, $container))) { continue; } try { $this->extensionConfig[$name] = $processor->processConfiguration($configuration, $config); } catch (\MailPoetVendor\Symfony\Component\Config\Definition\Exception\TreeWithoutRootNodeException $e) { } } } finally { \MailPoetVendor\Symfony\Component\Config\Definition\BaseNode::resetPlaceholders(); } $resolvingBag->clearUnusedEnvPlaceholders(); } public function getExtensionConfig() : array { try { return $this->extensionConfig; } finally { $this->extensionConfig = []; } } private static function getType($value) : string { switch ($type = \gettype($value)) { case 'boolean': return 'bool'; case 'double': return 'float'; case 'integer': return 'int'; } return $type; } } 